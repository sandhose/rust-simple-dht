.\" Automatically generated by Pandoc 2.0.4
.\"
.TH "SIMPLE_DHT" "1" "Décembre 2017" "" ""
.hy
.SH NOM
.PP
simple_dht \[en] Implémentation d'une table de hashage distribuée en
Rust
.SH SYNOPSIS
.PP
\f[B]simple_dht\f[] [\f[B]\-h\f[]] <commande>
.SH DESCRIPTION
.PP
\f[B]simple_dht\f[] est une table de hashage distribuée simple écrite en
Rust, à base d'E/S asynchrones (via tokio\-rs).
Plusieurs serveurs peuvent s'échanger des hash avec leur contenu.
Un hash envoyé à un serveur sera propagé dans tout le réseau.
.PP
Cet utilitaire comporte également un client, qui permet d'envoyer des
messages à un serveur.
.PP
Compilé et testé avec Rust 1.22.1 sur macOS.
.SH OPTIONS GÉNÉRALES
.TP
.B \f[B]\-h\f[], \f[B]\[en]help\f[]
Affiche le message d'aide
.RS
.RE
.SH COMMANDES
.TP
.B \f[B]server [hote:port]\f[]
Lance un serveur sur [hote:port] (par défaut: \f[I][::]:0\f[])
.RS
.RE
.TP
.B \f[B]client <hote:port> <commande>\f[]
Exécute une commande commandes sur un serveur distant
.RS
.RE
.TP
.B \f[B]help [sous\-commande]\f[]
Affiche l'aide d'une sous\-commande
.RS
.RE
.SS SOUS\-COMMANDE CLIENT
.PP
Ces commandes sont aussi utilisables dans le mode interactif du serveur.
.TP
.B \f[B]get <hash>\f[]
Récupère le contenu d'un hash
.RS
.RE
.TP
.B \f[B]put <hash> <contenu>\f[]
Envoie un hash
.RS
.RE
.TP
.B \f[B]discover <hote:port>\f[]
Signale un nouveau pair au serveur distant
.RS
.RE
.SH FONCTIONNEMENT DU PROTOCOLE
.PP
Un serveur possède un état, comportant la liste des hash connus, la
liste des pairs connus et une liste de requêtes en attente.
Lorsqu'il reçoit un message quelconque d'une source, il ajoute cette
source à la liste des pairs connus (qu'elle soit un serveur ou un
client).
Toutes les secondes, le serveur envoie un message \f[C]KeepAlive\f[] à
tous les pairs connus.
Un pair n'ayant pas donné de signe de vie depuis un certain temps est
considéré comme dépassé, et est supprimé de cette liste.
.PP
Lorsqu'un serveur reçois un message \f[C]Get(hash)\f[], il l'ajoute à la
liste des requêtes en attente.
Il va regarder régulièrement si avec la liste des hash qu'il connaît, il
peut résoudre une des requêtes en attente.
Si c'est le cas, il envoie un message \f[C]Put(hash)\f[] à celui qui a
demandé le hash.
.PP
Lorsqu'un serveur reçois un message \f[C]Put(hash,\ _)\f[], il ajoute le
hash à sa liste des hash connus, et envoie un message
\f[C]IHave(hash)\f[] à tous ses pairs connus.
.PP
Lorsqu'un serveur reçois un message \f[C]IHave(hash)\f[], il vérifie
s'il n'a pas déjà le hash annoncé, et si ce n'est pas le cas, il le
demande au pair distant en envoyant un message \f[C]Get(hash)\f[].
.PP
Lorsqu'un serveur reçois un message \f[C]Discover(pair)\f[], il ajoute
le pair à la liste des pairs connus.
À la boucle suivante, il enverra donc un \f[C]KeepAlive\f[] au pair tout
juste découvert, et établira ainsi la connexion.
.PP
En pratique, l'état est une structure partagée par plusieurs agents:
plusieurs sockets UDP et l'invite de commande interactive.
Rien n'empêche de faire tourner ces agents dans des threads différents,
ou d'implémenter relativement rapidement le protocole par dessus une
autre couche de transport (TCP).
.SH BUGS
.PP
Beaucoup d'erreurs ne sont pas attrapées proprement (mais il ne manque
pas grand chose pour qu'elles le soit).
Un message invalide arrêtera le serveur, tout comme la tentative d'envoi
d'un paquet sur une destination non joignable.
.PP
L'invite de commande interactive manque de finition.
Si un message apparaît dans la console entre\-temps, l'invite de
commande ne s'affiche plus forcément correctement.
.SH AUTHORS
Quentin Gliech <quentin.gliech@etu.unistra.fr>.
